<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#0a0a0a" />
    <link rel="manifest" href="manifest.webmanifest">
    <title>Interval Timer</title>
    <link rel="apple-touch-icon" href="icons/icon-192.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = { safelist: [
        'focus:border-emerald-400','focus:ring-emerald-500/30',
        'focus:border-sky-400','focus:ring-sky-500/30',
        'focus:border-violet-400','focus:ring-violet-500/30',
        'focus:border-amber-400','focus:ring-amber-500/30',
        'text-emerald-400','text-sky-400','text-purple-400','text-amber-400'
      ] };
    </script>
    <style>
      body { background:#0a0a0a; color:#e5e5e5; }
      #fallback{display:none;max-width:720px;margin:2rem auto;padding:1rem 1.25rem;background:#111;border:1px solid #333;border-radius:12px;font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
      #fallback h1{font-size:18px;margin:0 0 .5rem}
    </style>
  </head>
  <body class="min-h-screen">
    <div id="root"></div>
    <div id="fallback">
      <h1>Can’t load the app</h1>
      <p>This single-file build uses CDNs for React, ReactDOM, Babel, and Tailwind. If you open it offline before installing the PWA, you may see a blank page.</p>
      <p>Fixes: connect to the internet once to let the PWA cache files, then use it offline.</p>
    </div>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script>
      // Register the service worker
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('./service-worker.js').catch(console.error);
        });
      }
      // Show fallback if CDNs are unavailable
      window.addEventListener('load',function(){var ok=!!(window.React&&window.ReactDOM&&window.Babel);if(!ok){document.getElementById('fallback').style.display='block';}});
    </script>

    <script type="text/babel" data-presets="env,react">
      const { useEffect, useMemo, useRef, useState } = React;
      const STORAGE_KEY = "interval-timer:pwa-v1";

      function loadSaved(){ try{ const raw=localStorage.getItem(STORAGE_KEY); return raw?JSON.parse(raw):null;}catch{return null;} }
      function saveState(obj){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(obj)); }catch{} }
      function clamp(v,lo,hi){ return Math.max(lo, Math.min(v,hi)); }
      function toSeconds(v){ const n=Number(v); return Number.isFinite(n)&&n>=0?Math.round(n):0; }
      function fmt(mmss){ const m=Math.floor(mmss/60), s=mmss%60; return String(m)+":"+String(s).padStart(2,"0"); }

      function useBeep(enabled){
        const ctxRef=useRef(null);
        return (freq=880,durationMs=120)=>{
          if(!enabled) return;
          try{
            if(!ctxRef.current){
              const Ctx=window.AudioContext||window.webkitAudioContext;
              ctxRef.current=new Ctx();
            }
            const ctx=ctxRef.current;
            const t0=ctx.currentTime;
            const o=ctx.createOscillator();
            const g=ctx.createGain();
            o.type="sine";
            o.frequency.value=freq;
            g.gain.setValueAtTime(0.00001,t0);
            g.gain.exponentialRampToValueAtTime(0.22,t0+0.01);
            g.gain.exponentialRampToValueAtTime(0.00001,t0+durationMs/1000);
            o.connect(g).connect(ctx.destination);
            o.start(t0);
            o.stop(t0+durationMs/1000);
          }catch{}
        };
      }

      const presetList=[
        {name:"Wall Sits", work:30, rest:30, rounds:3},
        {name:"Planks", work:20, rest:20, rounds:3}
      ];

      function IntervalTimer(){
        const saved=useMemo(loadSaved,[]);
        const [work,setWork]=useState(saved?.work??20);
        const [rest,setRest]=useState(saved?.rest??10);
        const [rounds,setRounds]=useState(saved?.rounds??8);
        const [warmupDur,setWarmupDur]=useState(saved?.warmupDur??5);
        const [sound,setSound]=useState(saved?.sound??true);

        const [running,setRunning]=useState(false);
        const [phase,setPhase]=useState("work"); // warmup|work|rest|done
        const [round,setRound]=useState(1);
        const [remaining,setRemaining]=useState(work); // fractional seconds for smooth ring
        const [justSwitched,setJustSwitched]=useState(false);

        const announceRef=useRef(null), lastTick=useRef(null), lastWholeSecond=useRef(null);
        const totalTime=useMemo(()=>work*rounds+rest*(rounds-1)+warmupDur,[work,rest,rounds,warmupDur]);
        const beep=useBeep(sound);

        useEffect(()=>{ saveState({work,rest,rounds,warmupDur,sound}); },[work,rest,rounds,warmupDur,sound]);

        // Keep remaining synced when editing while stopped
        useEffect(()=>{
          if(!running){
            if(phase==="warmup") setRemaining(warmupDur);
            else if(phase==="work") setRemaining(work);
            else if(phase==="rest") setRemaining(rest);
            else setRemaining(0);
          }
        },[work,rest,warmupDur,phase,running]);

        // RAF tick: fractional seconds for smooth ring, 3-2-1 beeps for warm-up + rest
        useEffect(()=>{
          if(!running||phase==="done") return;
          let rafId;
          const tick=(t)=>{
            if(!lastTick.current) lastTick.current=t;
            const dt=t-lastTick.current; lastTick.current=t;
            setRemaining(prev=>{
              const next=prev-dt/1000;
              const nextClamped=next<=0?0:next;
              const whole=Math.max(0, Math.ceil(nextClamped));
              if(phase==="rest" || phase==="warmup"){
                if(lastWholeSecond.current!==whole){
                  if([3,2,1].includes(whole)) beep(750,140);
                  lastWholeSecond.current=whole;
                }
              }else{
                lastWholeSecond.current=whole;
              }
              if(next<=0.0001){ handlePhaseSwitch(); return 0; }
              return nextClamped;
            });
            rafId=requestAnimationFrame(tick);
          };
          rafId=requestAnimationFrame(tick);
          return ()=>cancelAnimationFrame(rafId);
        },[running,phase,work,rest,warmupDur,round,rounds]);

        const announce=(text)=>{ if(announceRef.current) announceRef.current.textContent=text; };

        const finish=()=>{
          // Upbeat 3-note arpeggio
          beep(784,180);
          setTimeout(()=>beep(880,180),170);
          setTimeout(()=>beep(988,260),340);
          setPhase("done"); setRunning(false); setRemaining(0);
          announce("Workout complete. Nice job!");
        };

        const handlePhaseSwitch=()=>{
          setJustSwitched(true); setTimeout(()=>setJustSwitched(false),500);
          if(phase==="warmup"){
            beep(1000,220);
            setPhase("work"); setRemaining(work); announce("Go! Work phase."); return;
          }
          if(phase==="work"){
            if(round>=rounds){ finish(); return; } // NO final rest; complete
            beep(1175,200);
            if(rest>0){ setPhase("rest"); setRemaining(rest); announce("Rest."); }
            else { advanceRound(); }
            return;
          }
          if(phase==="rest"){
            beep(880,200); advanceRound(); return;
          }
        };

        const advanceRound=()=>{
          if(round<rounds){
            setRound(r=>r+1);
            setPhase("work"); setRemaining(work);
          }else{
            finish();
          }
        };

        // Controls
        const start=()=>{
          if(phase==="done") reset();
          setPhase("warmup"); setRemaining(warmupDur); setRunning(true);
          lastTick.current=null; lastWholeSecond.current=null; announce("Warm-up");
        };
        const pause=()=>setRunning(false);
        const reset=()=>{ setRunning(false); setPhase("work"); setRound(1); setRemaining(work); lastTick.current=null; lastWholeSecond.current=null; };
        const skip=()=>{
          if(phase==="warmup"){ setPhase("work"); setRemaining(work); return; }
          if(phase==="work" && rest>0 && round<rounds){ setPhase("rest"); setRemaining(rest); }
          else { advanceRound(); }
        };
        const back=()=>{
          if(phase==="rest"){ setPhase("work"); setRemaining(work); }
          else if(phase==="work"){
            if(round>1){
              setRound(r=>r-1);
              if(rest>0){ setPhase("rest"); setRemaining(rest); } else { setPhase("work"); setRemaining(work); }
            }else{ setPhase("warmup"); setRemaining(warmupDur); }
          }
        };

        // Keyboard shortcuts
        useEffect(()=>{
          const onKey=(e)=>{
            if(e.target instanceof HTMLInputElement) return;
            if(e.code==="Space"){ e.preventDefault(); running?pause():start(); }
            else if(e.key.toLowerCase()==="r"){ reset(); }
            else if(e.key.toLowerCase()==="s"){ skip(); }
            else if(e.key.toLowerCase()==="b"){ back(); }
          };
          window.addEventListener("keydown", onKey);
          return ()=>window.removeEventListener("keydown", onKey);
        },[running,phase,work,rest,round,rounds,warmupDur]);

        const phaseDur = phase==="warmup"?warmupDur: phase==="work"?work: phase==="rest"?rest: 1;
        const remainingForProgress = clamp(remaining, 0, Math.max(1, phaseDur));
        const progress = 1 - remainingForProgress / Math.max(1, phaseDur);
        const displaySecs = Math.max(0, Math.round(remaining));
        const circle=useMemo(()=>{ const size=280, stroke=16, r=(size-stroke)/2, c=2*Math.PI*r; return {size,stroke,r,c}; },[]);
        const pct=Math.round(progress*100);

        const applyPreset=(p)=>{ setWork(p.work); setRest(p.rest); setRounds(p.rounds); reset(); };

        const showSettings = !running || phase === "done"; // hide while running

        return (
          <div className="min-h-screen w-full bg-neutral-950 text-neutral-100 flex items-center justify-center p-6">
            <div className={"w-full " + (showSettings ? "max-w-5xl" : "max-w-3xl")}>
              <div className={"grid gap-6 " + (showSettings ? "md:grid-cols-[1fr,1fr]" : "grid-cols-1")}>
                {/* Timer Panel */}
                <div className="bg-neutral-900/70 rounded-3xl p-6 shadow-xl border border-neutral-800">
                  <div className="flex items-center justify-between mb-4">
                    <h1 className="text-2xl md:text-3xl font-semibold tracking-tight">Interval Timer</h1>
                    <div className="text-xs opacity-70">Space = Start/Pause • R = Reset • S = Skip • B = Back</div>
                  </div>
                  <div className="flex flex-col items-center gap-6">
                    <div className={"relative " + (justSwitched ? "animate-pulse" : "")} aria-live="polite">
                      <svg width={circle.size} height={circle.size} className="rotate-[-90deg] block">
                        <circle cx={circle.size/2} cy={circle.size/2} r={circle.r} strokeWidth={circle.stroke} stroke="currentColor" className="text-neutral-800 fill-none" />
                        <circle cx={circle.size/2} cy={circle.size/2} r={circle.r} strokeWidth={circle.stroke} stroke="currentColor" strokeDasharray={circle.c} strokeDashoffset={circle.c*(1-progress)} strokeLinecap="round" className={(phase==="work"?"text-emerald-400":phase==="rest"?"text-sky-400":phase==="warmup"?"text-amber-400":"text-purple-400")+" fill-none"} />
                      </svg>
                      <div className="absolute inset-0 flex flex-col items-center justify-center text-center gap-1 rotate-0">
                        <div className="uppercase tracking-widest text-xs text-neutral-400">{phase==="done"?"Complete":phase}</div>
                        <div className="text-7xl md:text-8xl tabular-nums font-bold">{fmt(displaySecs)}</div>
                        <div className="text-sm text-neutral-400">{phase!=="warmup" ? (<>Round {round} / {rounds}</>) : "Warm-up"}</div>
                      </div>
                    </div>
                    <div className="flex flex-wrap items-center justify-center gap-3">
                      {!running ? (<button onClick={start} className="px-5 py-2.5 rounded-2xl bg-emerald-500 hover:bg-emerald-400 text-neutral-950 font-semibold shadow">Start</button>) : (<button onClick={pause} className="px-5 py-2.5 rounded-2xl bg-amber-400 hover:bg-amber-300 text-neutral-950 font-semibold shadow">Pause</button>)}
                      <button onClick={reset} className="px-4 py-2.5 rounded-2xl bg-neutral-800 hover:bg-neutral-700 font-medium">Reset</button>
                      <button onClick={back} disabled={round===1 && phase==="work"} className="px-4 py-2.5 rounded-2xl bg-neutral-800 hover:bg-neutral-700 font-medium disabled:opacity-40">Back</button>
                      <button onClick={skip} className="px-4 py-2.5 rounded-2xl bg-neutral-800 hover:bg-neutral-700 font-medium">Skip</button>
                    </div>
                    <div className="text-xs text-neutral-400">Progress: {pct}% • Total: {fmt(totalTime)}</div>
                  </div>
                </div>

                {/* Settings Panel (hidden while running) */}
                {showSettings && (
                  <div className="bg-neutral-900/70 rounded-3xl p-6 shadow-xl border border-neutral-800">
                    <h2 className="text-xl font-semibold mb-4">Settings</h2>
                    <div className="grid grid-cols-1 sm:grid-cols-4 gap-4 mb-4">
                      <NumberField label="Warm-up (sec)" value={warmupDur} onChange={(v)=>setWarmupDur(clamp(toSeconds(v),0,600))} min={0} max={600} color="amber" />
                      <NumberField label="Work (sec)" value={work} onChange={(v)=>setWork(clamp(toSeconds(v),0,3600))} min={0} max={3600} color="emerald" />
                      <NumberField label="Rest (sec)" value={rest} onChange={(v)=>setRest(clamp(toSeconds(v),0,3600))} min={0} max={3600} color="sky" />
                      <NumberField label="Rounds" value={rounds} onChange={(v)=>setRounds(clamp(toSeconds(v),1,200))} min={1} max={200} color="violet" />
                    </div>
                    <div className="flex items-center justify-between mb-4">
                      <div className="flex items-center gap-3">
                        <label className="text-sm text-neutral-300">Sound</label>
                        <button onClick={()=>setSound(s=>!s)} className={"px-3 py-1.5 rounded-xl text-sm font-medium "+(sound?"bg-emerald-500 text-neutral-950":"bg-neutral-800")}>{sound?"On":"Off"}</button>
                      </div>
                      <div className="flex items-center gap-2 text-xs text-neutral-400">
                        <span className="hidden sm:inline">Presets:</span>
                        {presetList.map(p=>(<button key={p.name} onClick={()=>applyPreset(p)} className="px-2.5 py-1.5 rounded-2xl bg-neutral-800 hover:bg-neutral-700 text-neutral-200">{p.name}</button>))}
                      </div>
                    </div>
                    <div className="rounded-2xl bg-neutral-950/40 border border-neutral-800 p-3 text-xs text-neutral-400 leading-relaxed">
                      <p className="mb-1"><span className="text-neutral-300 font-medium">Tips:</span> Starts with a <span className="text-amber-400">{warmupDur}s warm-up</span> (beeps at 3–2–1), then cycles Work/Rest (beeps at 3–2–1 of REST). After the last WORK round, the timer completes immediately with an upbeat sound.</p>
                      <p>Keyboard: <kbd className="bg-neutral-800 px-1 rounded">Space</kbd> start/pause • <kbd className="bg-neutral-800 px-1 rounded">R</kbd> reset • <kbd className="bg-neutral-800 px-1 rounded">S</kbd> skip • <kbd className="bg-neutral-800 px-1 rounded">B</kbd> back.</p>
                    </div>
                  </div>
                )}

                {/* SR announcements */}
                <div aria-live="assertive" aria-atomic="true" className="sr-only" ref={announceRef} />
              </div>
            </div>
          </div>
        );
      }

      function NumberField({label,value,onChange,min=0,max=9999,disabled,color="emerald"}){
        const focusBorder="focus:border-"+color+"-400";
        const focusRing="focus:ring-2 focus:ring-"+color+"-500/30";
        return (
          <label className="block">
            <div className="text-xs mb-1 text-neutral-400">{label}</div>
            <div className="flex items-center gap-2">
              <input
                type="number"
                min={min}
                max={max}
                value={value}
                disabled={disabled}
                onChange={(e)=>onChange(e.target.value)}
                className={"w-full rounded-2xl bg-neutral-800 text-neutral-100 px-3 py-2 outline-none border border-neutral-700 "+focusBorder+" "+focusRing}
              />
            </div>
          </label>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<IntervalTimer />);
    </script>
  </body>
</html>
